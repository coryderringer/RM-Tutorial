{% extends "_base.htm" %}
{% block title %}
	Sim 1!!
{% endblock%}


{% block bodycontent %}

<form id="dataform" method="post" action="/WithinSubject">
	<input id="Q3" name="Q3" type="hidden">
	<input id="numbersims" name="numbersims" type="hidden">
	<input id="progressinput" name="progressinput" type="hidden">
	<input id="Submit" onclick="MySubmit()" value="Submit" type="hidden">
</form>


<div class="pg">
	<center>
		<div id="firstrow">
			<div id="between1" style="display:inline-block">
				<div id="graph1"></div>
				
				<!-- <div id="ttest1" class="ttest">
					<span id="tspan1">t=1.00</span><br>
					<span id="pspan1">p=.50</span><br>
					<span id="dspan1">power=.8</span><br>
				</div> -->
			</div>
			
			<div id="within1" style="display:inline-block">
				<div id="graph2"></div>
			</div>
			<button onclick="UpdateData()">Click Me!</button>
		</div>
		<br>

		<div id="secondrow" style="display:none">
			<div id="between2" style="display:inline-block;margin-right:100px">
				<div class="pg" style="display:inline-block;margin-right:20px;padding:5px;width:200px">
					<IMG src="/static/images/testimage.png" style="width:200px"></IMG>
				</div>
				<div id="ttest3" class="ttest">
					<span id="tspan1">t=1.00</span><br>
					<span id="pspan1">p=.50</span><br>
					<span id="dspan1">power=.8</span><br>
				</div>
			</div>
			
			<div id="within2" style="display:inline-block">
				<div class="pg" style="display:inline-block;margin-right:20px;padding:5px;width:200px">
					<IMG src="/static/images/testimage.png" style="width:200px"></IMG>
				</div>
				<div id="ttest4" class="ttest">
					<span id="tspan2">t=1.00</span><br>
					<span id="pspan2">p=.50</span><br>
					<span id="dspan2">power=.8</span><br>
				</div>
			</div>
		</div>
		<br>
		<button id="ResampleButton" style="width:100px;display:none;position:relative;left:-20px" onclick="ResampleFunction()">Resample</button>
	</center>	
	<br>

	<div id="Text1">
		<p>To expand on this point, let's look at what each design is actually comparing between the two conditions. On the left we have a between-subjects approach and on the right we have the same datapoints collected in a within-subjects design.</p>

		<p>Notice that the dependent variable (on the Y axis) is different between these two designs. This is a natural result of the difference between the questions we're asking with these designs. In a between subjects design, we want to know if one group is different from another group after some treatment. In a within subjects design, we want to know if one treatment works better than the other treatment for the same group of people. Click the "Learn More" button below to learn more about how these datasets were simulated.</p>

		<div id="Quiz3">
			<p id="Question3">Intuitively, which chart would you say is more convincing (i.e. which shows the Vegetable Condition having a stronger effect?)</p>


			<form id="Q3Answers">
				<input type="radio" name="q3" value="A" id="q3a"><label for="q3a">The between-subjects design</label><br>
				<input type="radio" name="q3" value="B" id="q3b"><label for="q3b">The within-subjects design</label><br>
			</form><br>

			<button id="AnswerButton3" onclick="RecordQuiz3()" style="width:100px">Next</button>
			<button id="LearnButton" onclick="LearnVisible()" style="float:right">Learn More</button>
			<br>
			<div id="ResponseDiv3" style=""></div>
		<div id="DataGenerationExplanation" class="pg" style="display:none;width:700px;border:2px solid gray;margin-top:20px">
			<center><b>Data Simulations:</b></center><br>
			To mimic the process of drawing a sample from the population, each design is simulated here by drawing a random sample from a normal distribution (mean = 200, standard deviation = 10).<br>
			<br>
			<b>In the between subjects design,</b> we would then randomly assign each person to one condition or the other. Because the treatments will not affect everyone the same way, we should represent the effectiveness of each treatment probabilistically using another normal distribution (mean weight loss for the fruit group was 10 pounds, 25 for the vegetable group, with a standard devation of 5 pounds per group). These adjusted weights represent each participant's weight after the treatment (our dependent variable).<br>
			<br>
			<b>In the within subjects design,</b> we can draw a sample just like before from a normal distribution with a mean of 200 and a standard deviation of 10. Additionally, each individual gets an adjustment representing the amount of weight they lost in each condition. <b>Importantly, because we're comparing the same group at two different timepoints, we really only care about these adjustments.</b> The baseline distribution itself could have a mean of 300 or 100, with a standard deviation of 5 or 50, and it would make no difference on the outcome for a within subjects design. This is because instead of testing the difference between the means of each group, we take each individual's difference score (the difference between their weight lost in the fruit condition and in the vegetable condition), and test to see if the mean of the difference scores is significantly greater than zero.
		</div>
		</div>
	</div>

	<div id="AnswerA" style="display:none">
		<p>Oh no, your intuition wasn't right this time! That's okay.</p>
	</div>
	<div id="AnswerB" style="display:none">
		<p>Right!</p>
	</div>
	<div id="Text2" style="display:none">
		<p>This is the first advantage of within subject designs: <i>they're insensitive to the population variance</i>. Look at the wide distribution of weights in each condition for both graphs. With a between subjects design (left side), we're punished statistically by the question we're asking. When we want to know if the difference between the group means is reliably (i.e. significantly) greater than zero, we have to have a context against which to judge the difference. That context is the variation in each group: the wider each group is spread, the more power we lose in a between subjects design.</p>

		<p>Asking a different question with a within subjects design means that the differences within each condition will only affect our statistical power if they affect the consistency of the difference scores (i.e. if they're the result of differences in the effectiveness of the treatment), <i>but they will not affect our power if they're the result of individual differences unrelated to the treatment, which is the case here!</i></p>
	</div>

	<div id="Text3" style="display:none">
		<p>Here we can see that the between subjects design does much better when the population variance is low. With each group more tightly distributed around its mean, it’s easier to tell that there is a real difference between the group means. However, notice that the p value for the within subjects design is just as low. In fact, it is exactly the same as it is above, because within subjects designs are not affected by the population variance like between subjects designs.</p>

		<p>Take a minute or two to play around with this simulator a bit. See what happens when you generate different datasets using the "Resample" button: how often is the within subjects design significant when the between subjects design isn’t? Is that pattern ever reversed?</p>
	</div>

	<button id="NextButton" style="width:100px;display:none">Continue</button>


</div>

<script>





var Q3Outcome = 'unanswered';
var datasets = 1;
var progress = {{progress}};
var LearnDiv = 0;

function LearnVisible(){
	if(LearnDiv == 0){
		LearnDiv += 1;
	}
	$('#DataGenerationExplanation').toggle();
}

function RecordQuiz3(){
	Q3Outcome = $('input[name=q3]:checked', '#Q3Answers').val();
	if(Q3Outcome != 'A' & Q3Outcome != 'B'){
		alert('Please make a selection!');
		return
	
	}else if(Q3Outcome == 'A'){
		$('#AnswerA').show();

	}else if (Q3Outcome == 'B'){
		$('#AnswerB').show();
		
	}
	$('#Text1').hide();
	
	// Show response and next button
	$('#Text2, #NextButton').show();
	
	$('#NextButton').click(function(){
		
		// Hide quiz, answers
		$('#Text1, #Text2, #AnswerA, #AnswerB').hide();

		// Show second row and instructions, resample button
		$('#secondrow, #Text3, #ResampleButton').show();
		

		// Next button: move on after simulations
		$('#NextButton').click(MySubmit);
		$('#NextButton').css('display', 'inline-block');
		$('#NextButton').css('float', 'right');	
	
	});
}

function ResampleFunction(){
	// Generate new data
	datasets += 1;
	console.log('Resampling!');

}


function MySubmit(){
	console.log('Submitting!');
	progress +=1;
	$('#Q3').val(Q3Outcome);
	$('#progressinput').val(String(progress));
	$('#numbersims').val(datasets);
	$('#dataform').submit();
}



/// Graph
// list of files
var BetweenFileList = ['/static/stimuli/WithinSubjects/between1.csv', '/static/stimuli/WithinSubjects/between2.csv', '/static/stimuli/WithinSubjects/between3.csv', '/static/stimuli/WithinSubjects/between4.csv', '/static/stimuli/WithinSubjects/between5.csv'];

var WithinFileList = ['/static/stimuli/WithinSubjects/within1.csv', '/static/stimuli/WithinSubjects/within2.csv', '/static/stimuli/WithinSubjects/within3.csv', '/static/stimuli/WithinSubjects/within4.csv', '/static/stimuli/WithinSubjects/within5.csv']

// Randomly select a file from the list
var BetweenFile = BetweenFileList[Math.floor(Math.random() * BetweenFileList.length)];

var WithinFile = WithinFileList[Math.floor(Math.random() * WithinFileList.length)];


/// Name variables here
var	yLabel = "Weight",
	condLabel = "Exercise routine",
	xMax = 20,
	yMax1 = 250;
	yMax2 = 40

/// Variables for calculating stuff
var parsedData;
var iv = [];
var dv = [];
var measure = [];
var meanVeggieBetween = [];
var meanFruitBetween = [];
var meanVeggieWithin = [];
var meanFruitWithin = [];


/// Function for noise
function randomJitter(min, max) {
  return Math.random() * (max - min) + min;
}


var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 300 - margin.left - margin.right,
    height = 200 - margin.top - margin.bottom;

var x = d3.scale.linear()
    .range([0, width])
    .domain([0,xMax+1]);

var y1 = d3.scale.linear()
    .range([height, 0])
    .domain([100,yMax1]);

var y2 = d3.scale.linear()
    .range([height, 0])
    .domain([-5,yMax2]);

var cond = d3.scale.ordinal()
    .rangePoints([0, width],1)
    .domain(["Veggie","Fruit"]);

var color = d3.scale.category10()
    .domain(["Veggie","Fruit"]);

var xAxis = d3.svg.axis()
    .scale(cond)
    .orient("bottom")
    // .ticks(xMax/2);

var yAxis1 = d3.svg.axis()
    .scale(y1)
    .orient("left");

var yAxis2 = d3.svg.axis()
    .scale(y2)
    .orient("left");

var chart1 = d3.select("#graph1").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  	.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var chart2 = d3.select("#graph2").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  	.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// var line = d3.chart1.line()
// 	.interpolate("basis")
//     .x(function(d) { return x(d.t); })
//     .y(function(d) { return y(d.measure); });

// Sets attributes of blockers

// var lineBlockerAttr = new Object();
// 	lineBlockerAttr.x=width/3;
// 	lineBlockerAttr.y=0;

// var pointBlockerAttr = new Object();
// 	pointBlockerAttr.x=width/2;
// 	pointBlockerAttr.y=0;

// Reads data from .csv file

// for between subjects
d3.csv(BetweenFile, function(error, data) {
  	if (error) throw error;

    //////// Saves data for calculation ////////
    parsedData = JSON.parse(JSON.stringify(data));
  
    for (i = 0; i < parsedData.length; i++) {
      iv.push(Number(parsedData[i].iv));
      dv.push(Number(parsedData[i].dv));
      measure.push(Number(parsedData[i].measure));

      if (parsedData[i].condition=="Veggie") {
        meanVeggieBetween.push(Number(parsedData[i].dv));
      }
      else if (parsedData[i].condition=="Fruit") {
        meanFruitBetween.push(Number(parsedData[i].dv));
      }
    }
    ////////////////////////////////////////////

  	data.forEach(function(d) {
    	d.iv = +d.iv + randomJitter(-0.3,0.3);
    	d.dv = +d.dv;
    	d.t = +d.t;
    	d.condition = d.condition;
  	});

  	// create the scales x() and y()
  	// x.domain([0,xMax+1]);
  	// y.domain([0,yMax]);


    // Appends lines for means

    var VeggieMeanBetween = chart1.append("line")
      .attr("x1", cond("Veggie")-x(1))
      .attr("x2", cond("Veggie")+3*x(1))
      .attr("y1", y1(d3.mean(meanVeggieBetween)))
      .attr("y2", y1(d3.mean(meanVeggieBetween)))
      .attr("stroke", color("Veggie"));

    var FruitMeanBetween = chart1.append("line")
      .attr("x1", cond("Fruit")-3*x(1))
      .attr("x2", cond("Fruit")+x(1))
      .attr("y1", y1(d3.mean(meanFruitBetween)))
      .attr("y2", y1(d3.mean(meanFruitBetween)))
      .attr("stroke", color("Fruit"));

    // Appends points

  	chart1.selectAll(".dot")
      	.data(data)
   	.enter().append("circle")
      	.attr("class", "dot")
      	.attr("r", 3.5)
      	.attr("cx", function(d) { return cond(d.condition) + randomJitter(-10,10); })
      		// Not great because it's not scaled, but it works for now
      	.attr("cy", function(d) { return y1(d.dv); })
      	.style("fill", function(d) { return color(d.condition); })
      	.style("opacity", 1);

    // Appends axes

  	chart1.append("g")
    	.attr("class", "x axis")
      	.attr("transform", "translate(0," + height + ")")
      	.call(xAxis)


  	chart1.append("g")
      	.attr("class", "y axis")
      	.call(yAxis1)
   	.append("text")
    	.attr("class", "label")
    	.attr("transform", "rotate(-90)")
    	.attr("y", 6)
    	.attr("dy", ".71em")
    	.style("text-anchor", "end")
    	.text(yLabel)

    // Appends legend

  	var legend = chart1.selectAll(".legend")
      	.data(color.domain())
    .enter().append("g")
      	.attr("class", "legend")
      	.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

  	legend.append("rect")
      	.attr("x", width - 18)
      	.attr("width", 18)
      	.attr("height", 18)
      	.style("fill", color);

  	legend.append("text")
      	.attr("x", width - 24)
      	.attr("y", 9)
      	.attr("dy", ".35em")
      	.style("text-anchor", "end")
      	.text(function(d) { return d; });



});

// for within subjects
d3.csv(WithinFile, function(error, data) {
  	if (error) throw error;

    //////// Saves data for calculation ////////
    parsedData2 = JSON.parse(JSON.stringify(data));
  
    for (i = 0; i < parsedData.length; i++) {
      iv.push(Number(parsedData2[i].iv));
      dv.push(Number(parsedData2[i].dv));
      measure.push(Number(parsedData2[i].measure));

      if (parsedData[i].condition=="Veggie") {
        meanVeggieWithin.push(Number(parsedData2[i].dv));
      }
      else if (parsedData[i].condition=="Fruit") {
        meanFruitWithin.push(Number(parsedData2[i].dv));
      }
    }
    ////////////////////////////////////////////

  	data.forEach(function(d) {
    	d.iv = +d.iv + randomJitter(-0.3,0.3);
    	d.dv = +d.dv;
    	d.t = +d.t;
    	d.condition = d.condition;
  	});

  	// create the scales x() and y()
  	// x.domain([0,xMax+1]);
  	// y.domain([0,yMax]);


    // Appends lines for means

    var VeggieMeanWithin = chart2.append("line")
      .attr("x1", cond("Veggie")-x(1))
      .attr("x2", cond("Veggie")+3*x(1))
      .attr("y1", y2(d3.mean(meanVeggieWithin)))
      .attr("y2", y2(d3.mean(meanVeggieWithin)))
      .attr("stroke", color("Veggie"));

    var FruitMeanWithin = chart2.append("line")
      .attr("x1", cond("Fruit")-3*x(1))
      .attr("x2", cond("Fruit")+x(1))
      .attr("y1", y2(d3.mean(meanFruitWithin)))
      .attr("y2", y2(d3.mean(meanFruitWithin)))
      .attr("stroke", color("Fruit"));

    // Appends points

  	chart2.selectAll(".dot")
      	.data(data)
   	.enter().append("circle")
      	.attr("class", "dot")
      	.attr("r", 3.5)
      	.attr("cx", function(d) { return cond(d.condition)+ randomJitter(-10,10); })
      		// Not great because it's not scaled, but it works for now
      	.attr("cy", function(d) { return y2(d.dv); })
      	.style("fill", function(d) { return color(d.condition); })
      	.style("opacity", 1);

    // Appends axes

  	chart2.append("g")
    	.attr("class", "x axis")
      	.attr("transform", "translate(0," + height + ")")
      	.call(xAxis)


  	chart2.append("g")
      	.attr("class", "y axis")
      	.call(yAxis2)
   	.append("text")
    	.attr("class", "label")
    	.attr("transform", "rotate(-90)")
    	.attr("y", 6)
    	.attr("dy", ".71em")
    	.style("text-anchor", "end")
    	.text(yLabel)

    // Appends legend

  	var legend = chart2.selectAll(".legend")
      	.data(color.domain())
    .enter().append("g")
      	.attr("class", "legend")
      	.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

  	legend.append("rect")
      	.attr("x", width - 18)
      	.attr("width", 18)
      	.attr("height", 18)
      	.style("fill", color);

  	legend.append("text")
      	.attr("x", width - 24)
      	.attr("y", 9)
      	.attr("dy", ".35em")
      	.style("text-anchor", "end")
      	.text(function(d) { return d; });

});

function UpdateData(){
	$('#graph1').html('');
	meanFruit = []
	meanVeggie = []

	$('#graph2').html('');


	// randomly select a datafile

	random = Math.floor(Math.random() * BetweenFileList.length)

	var Between = BetweenFileList[random]

	var Within = WithinFileList[random]

	var chart1 = d3.select("#graph1").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	  	.append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	var chart2 = d3.select("#graph2").append("svg")
	    .attr("width", width + margin.left + margin.right)
	    .attr("height", height + margin.top + margin.bottom)
	  	.append("g")
	    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

	// generate the graph again for between
	d3.csv(BetweenFile, function(error, data) {
	  	if (error) throw error;

	    //////// Saves data for calculation ////////
	    parsedData = JSON.parse(JSON.stringify(data));
	  
	    for (i = 0; i < parsedData.length; i++) {
	      iv.push(Number(parsedData[i].iv));
	      dv.push(Number(parsedData[i].dv));
	      measure.push(Number(parsedData[i].measure));

	      if (parsedData[i].condition=="Veggie") {
	        meanVeggieBetween.push(Number(parsedData[i].dv));
	      }
	      else if (parsedData[i].condition=="Fruit") {
	        meanFruitBetween.push(Number(parsedData[i].dv));
	      }
	    }
	    ////////////////////////////////////////////

	  	data.forEach(function(d) {
	    	d.iv = +d.iv + randomJitter(-0.3,0.3);
	    	d.dv = +d.dv;
	    	d.t = +d.t;
	    	d.condition = d.condition;
	  	});

	  	// create the scales x() and y()
	  	// x.domain([0,xMax+1]);
	  	// y.domain([0,yMax]);


	    // Appends lines for means

	    var VeggieMeanBetween = chart1.append("line")
	      .attr("x1", cond("Veggie")-x(1))
	      .attr("x2", cond("Veggie")+3*x(1))
	      .attr("y1", y1(d3.mean(meanVeggieBetween)))
	      .attr("y2", y1(d3.mean(meanVeggieBetween)))
	      .attr("stroke", color("Veggie"));

	    var FruitMeanBetween = chart1.append("line")
	      .attr("x1", cond("Fruit")-3*x(1))
	      .attr("x2", cond("Fruit")+x(1))
	      .attr("y1", y1(d3.mean(meanFruitBetween)))
	      .attr("y2", y1(d3.mean(meanFruitBetween)))
	      .attr("stroke", color("Fruit"));

	    // Appends points

	  	chart1.selectAll(".dot")
	      	.data(data)
	   	.enter().append("circle")
	      	.attr("class", "dot")
	      	.attr("r", 3.5)
	      	.attr("cx", function(d) { return cond(d.condition)+ randomJitter(-10,10); })
	      		// Not great because it's not scaled, but it works for now
	      	.attr("cy", function(d) { return y1(d.dv); })
	      	.style("fill", function(d) { return color(d.condition); })
	      	.style("opacity", 1);

	    // Appends axes

	  	chart1.append("g")
	    	.attr("class", "x axis")
	      	.attr("transform", "translate(0," + height + ")")
	      	.call(xAxis)


	  	chart1.append("g")
	      	.attr("class", "y axis")
	      	.call(yAxis1)
	   	.append("text")
	    	.attr("class", "label")
	    	.attr("transform", "rotate(-90)")
	    	.attr("y", 6)
	    	.attr("dy", ".71em")
	    	.style("text-anchor", "end")
	    	.text(yLabel)

	    // Appends legend

	  	var legend = chart1.selectAll(".legend")
	      	.data(color.domain())
	    .enter().append("g")
	      	.attr("class", "legend")
	      	.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

	  	legend.append("rect")
	      	.attr("x", width - 18)
	      	.attr("width", 18)
	      	.attr("height", 18)
	      	.style("fill", color);

	  	legend.append("text")
	      	.attr("x", width - 24)
	      	.attr("y", 9)
	      	.attr("dy", ".35em")
	      	.style("text-anchor", "end")
	      	.text(function(d) { return d; });



	});

	// generate the graph again for within
	d3.csv(WithinFile, function(error, data) {
	  	if (error) throw error;

	    //////// Saves data for calculation ////////
	    parsedData2 = JSON.parse(JSON.stringify(data));
	  
	    for (i = 0; i < parsedData.length; i++) {
	      iv.push(Number(parsedData2[i].iv));
	      dv.push(Number(parsedData2[i].dv));
	      measure.push(Number(parsedData2[i].measure));

	      if (parsedData[i].condition=="Veggie") {
	        meanVeggieWithin.push(Number(parsedData2[i].dv));
	      }
	      else if (parsedData[i].condition=="Fruit") {
	        meanFruitWithin.push(Number(parsedData2[i].dv));
	      }
	    }
	    ////////////////////////////////////////////

	  	data.forEach(function(d) {
	    	d.iv = +d.iv + randomJitter(-0.3,0.3);
	    	d.dv = +d.dv;
	    	d.t = +d.t;
	    	d.condition = d.condition;
	  	});

	  	// create the scales x() and y()
	  	// x.domain([0,xMax+1]);
	  	// y.domain([0,yMax]);


	    // Appends lines for means

	    var VeggieMeanWithin = chart2.append("line")
	      .attr("x1", cond("Veggie")-x(1))
	      .attr("x2", cond("Veggie")+3*x(1))
	      .attr("y1", y2(d3.mean(meanVeggieWithin)))
	      .attr("y2", y2(d3.mean(meanVeggieWithin)))
	      .attr("stroke", color("Veggie"));

	    var FruitMeanWithin = chart2.append("line")
	      .attr("x1", cond("Fruit")-3*x(1))
	      .attr("x2", cond("Fruit")+x(1))
	      .attr("y1", y2(d3.mean(meanFruitWithin)))
	      .attr("y2", y2(d3.mean(meanFruitWithin)))
	      .attr("stroke", color("Fruit"));

	    // Appends points

	  	chart2.selectAll(".dot")
	      	.data(data)
	   	.enter().append("circle")
	      	.attr("class", "dot")
	      	.attr("r", 3.5)
	      	.attr("cx", function(d) { return cond(d.condition)+ randomJitter(-10,10); })
	      		// Not great because it's not scaled, but it works for now
	      	.attr("cy", function(d) { return y2(d.dv); })
	      	.style("fill", function(d) { return color(d.condition); })
	      	.style("opacity", 1);

	    // Appends axes

	  	chart2.append("g")
	    	.attr("class", "x axis")
	      	.attr("transform", "translate(0," + height + ")")
	      	.call(xAxis)


	  	chart2.append("g")
	      	.attr("class", "y axis")
	      	.call(yAxis2)
	   	.append("text")
	    	.attr("class", "label")
	    	.attr("transform", "rotate(-90)")
	    	.attr("y", 6)
	    	.attr("dy", ".71em")
	    	.style("text-anchor", "end")
	    	.text(yLabel)

	    // Appends legend

	  	var legend = chart2.selectAll(".legend")
	      	.data(color.domain())
	    .enter().append("g")
	      	.attr("class", "legend")
	      	.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

	  	legend.append("rect")
	      	.attr("x", width - 18)
	      	.attr("width", 18)
	      	.attr("height", 18)
	      	.style("fill", color);

	  	legend.append("text")
	      	.attr("x", width - 24)
	      	.attr("y", 9)
	      	.attr("dy", ".35em")
	      	.style("text-anchor", "end")
	      	.text(function(d) { return d; });



	});
}
</script>

{% endblock %}